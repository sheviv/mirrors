import numpy as np

# Имеются ли в массиве какие-либо значения, превышающие 8?
# np.any(x > 8)
# Имеются ли в массиве какие-либо значения меньше 0?
# np.any(x < 0)

# Все ли значения равны 6?
# np.all(x == 6)

# Можно применять совместно «прихотливые» и простые индексы:
# X = [[ 0 1 2 3]
# [ 4 5 6 7]
# [ 8 9 10 11]]
# X[2, [2, 0, 1]]
# array([10, 8, 9])

# «прихотливуя» индексация. Работа со значениями по индексам(прибавление 1 для каждого индекса i)
# x = np.zeros(10)
# i = [2, 3, 3, 4, 4, 4]
# np.add.at(x, i, 1)
# print(x)
# [ 0. 0. 1. 2. 3. 0. 0. 0. 0. 0.]

# отсортированнуя версия входного массива
# x = np.array([2, 1, 4, 3, 5])
# np.sort(x)

# индексы отсортированных элементов:
# x = np.array([2, 1, 4, 3, 5])
# i = np.argsort(x)
# [1 0 3 2 4]

# Сортируем все столбцы массива X
# любые возможные взаимосвязи между значениями строк или столбцов будут утеряны.
# np.sort(X, axis=0)
# Сортируем все строки массива X
# np.sort(X, axis=1)

# Первые n значения в итоговом массиве — n наименьших значения в нем
# n = 3
# x = np.array([7, 2, 3, 1, 6, 5, 4])
# np.partition(x, n)
# array([2, 1, 3, 4, 6, 5, 7])

# массив, в котором на первых n(двух) позициях в каждой строке находятся наименьшие значения из этой строки
# np.partition(X, 2, axis=1)
# Out[13]: array([[3, 4, 6, 7, 6, 9],
# [2, 3, 4, 7, 6, 7],
# [1, 2, 4, 5, 7, 7],
# [0, 1, 4, 5, 9, 5]])

# K ближайших соседей. массив 10 × 2:
# X = rand.rand(10, 2)
# матрицу квадратов расстояний(1-ый спобоб)
# dist_sq = np.sum((X[:,np.newaxis,:] - X[np.newaxis,:,:]) ** 2, axis=-1)
# Для каждой пары точек вычисляем разности их координат
# differences = X[:, np.newaxis, :] - X[np.newaxis, :, :]
# Возводим разности координат в квадрат
# sq_differences = differences ** 2
# Суммируем квадраты разностей координат(2-ый спобоб)
# dist_sq = sq_differences.sum(-1)
# проверка, что диагональ матрицы (то есть набор расстояний между каждой точкой и ей самой) состоит из нулей:
# dist_sq.diagonal()
# np.argsort - сортировка по каждой строке. Крайние слева столбцы - индексы ближайших соседей:
# nearest = np.argsort(dist_sq, axis=1)
# первый столбец - числа с 0 до 9 в порядке возрастания: ближайший сосед каждой точки — она сама

# K ближайших соседей. Секционировать все строки так, чтобы сначала шли K+1 минимальных квадратов расстояний, а бОольшие расстояния
# заполняли оставшиеся позиции массива np.argpartition:
# K = 2
# nearest_partition = np.argpartition(dist_sq, K + 1, axis=1)
# plt.scatter(X[:, 0], X[:, 1], s=100)
# Рисуем линии из каждой точки к ее двум ближайшим соседям
# for i in range(X.shape[0]):
#     for j in nearest_partition[i, :K+1]:
# чертим линию от X[i] до X[j]
# Используем для этого «магическую» функцию zip:
# plt.plot(*zip(X[j], X[i]), color='black')