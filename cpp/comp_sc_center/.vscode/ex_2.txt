Указатели
∙ Указатель — это переменная, хранящая адрес некоторой ячейки памяти.
∙ Указатели являются типизированными.
int i = 3; // переменная типа int
int * p = 0; // указатель на переменную типа int
∙ Нулевому указателю (которому присвоено значение 0) не соответствует никакая ячейка памяти.
∙ Оператор взятия адреса переменной &.
∙ Оператор разыменования *.
p = & i ; // указатель p указывает на переменную i
* p = 10; // изменяется ячейка по адресу p, т.е. i

Передача параметров по указателю
Вместо значений типа int будем передавать указатели.
//swap изменяет переменные k и m по указателям на них
void swap(int * a, int * b)
{
    int t = * a;
    * a = * b;
    * b = t;
}
int main ()
{
    int k = 10 , m = 20;
    swap (& k , & m );
    cout << k << ’ ’ << m << endl; // 20 10
    return 0;
}

Массивы
∙ Массив — это набор однотипных элементов, расположенных в памяти друг за другом, доступ к которым осуществляется по индексу.
// массив 1 2 3 4 5 0 0 0 0 0
int m [10] = {1 , 2 , 3 , 4 , 5};  //[10] - кол-вво эл. в массиве.
∙ Индексация массива начинается с 0, последний элемент массива длины n имеет индекс n - 1.
for (int i = 0; i < 10; ++i)
{
    cout << m [ i ] << ’ ’;
    cout << endl;
}

Массивы и указатели
∙ Указатели позволяют передвигаться по массивам.
∙ Для этого используется арифметика указателей:
int m [10] = {1 , 2 , 3 , 4 , 5};
int * p = & m [0]; // адрес начала массива
int * q = & m [9]; // адрес последнего элемента
∙ (p + k) — сдвиг на k ячеек типа int вправо.
∙ (p - k) — сдвиг на k ячеек типа int влево.
∙ (q - p) — количество ячеек между указателями.
∙ p[k] эквивалентно *(p + k).

Заполнение массива:
int m [10] = {}; // изначально заполнен нулями
//           &m[0]       &m[9]
for (int * p = m ; p <= m + 9; ++ p)
    * p = ( p - m ) + 1;
// Массив заполнен числами от 1 до 10
Передача массива в функцию:
int max_element (int * m , int size)
{
    int max = * m;
    for (int i = 1; i < size ; ++ i)
        if (m[i] > max)
            max = m[i];
    return max ;
}

∙ Для того, чтобы исправить некоторые недостатки указателей, в C++ введены ссылки.
∙ Ссылки являются “красивой обёрткой” над указателями:
void swap ( int & a , int & b ) {
int t = b ;
b = a ;
a = t ;
}
int main ()
{
int k = 10 , m = 20;
swap (k , m );
cout << k << ’ ’ << m << endl ; // 20 10
return 0;
}

Различия ссылок и указателей
∙ Ссылка не может быть неинициализированной.
int * p ; // OK
int & l ; // ошибка
∙ У ссылки нет нулевого значения.
int * p = 0; // OK
int & l = 0; // ошибка
∙ Ссылку нельзя переинициализировать.
int a = 10 , b = 20;
int * p = & a ; // p указывает на a
p = & b; // p указывает на b
int & l = a ; // l ссылается на a
l = b ; // a присваивается значение b

Различия ссылок и указателей
∙ Нельзя получить адрес ссылки или ссылку на ссылку.
int a = 10;
int * p = & a ; // p указывает на a
int ** pp = & p ;// pp указывает на переменную p
int & l = a ; // l ссылается на a
int * pl = & l ; // pl указывает на переменную a
int && ll = l ; // ошибка
∙ Нельзя создавать массивы ссылок.
int * mp [10] = {}; // массив указателей на int
int & ml [10] = {}; // ошибка

lvalue и rvalue
∙ Выражения в C++ можно разделить на два типа:
1. lvalue — выражения, значения которых являются ссылкой на переменную/элемент массива, а значит могут быть указаны слева от оператора =.
2. rvalue — выражения, значения которых являются временными и не соответствуют никакой переменной/элементу массива.
∙ Указатели и ссылки могут указывать только на lvalue.
int a = 10 , b = 20;
int m [10] = {1 ,2 ,3 ,4 ,5 ,5 ,4 ,3 ,2 ,1};
int & l1 = a ; // OK
int & l2 = a + b ; // ошибка
int & l3 = *( m + a / 2); // OK
int & l4 = *( m + a / 2) + 1; // ошибка
int & l5 = ( a + b > 10) ? a : b ; // OK

Время жизни переменной
Следует следить за временем жизни переменных.
int * foo () {
int a = 10;
return & a ;
}
int & bar () {
int b = 20;
return b ;
}
int * p = foo ();
int & l = bar ();

Зачем нужна динамическая память?
∙ Стек программы ограничен. Он не предназначен для хранения больших объемов данных.
// Не умещается на стек
double m [10000000] = {}; // 80 Mb
∙ Время жизни локальных переменных ограничено временем работы функции.
∙ Динамическая память выделяется в сегменте данных.
∙ Структура, отвечающая за выделение дополнительной памяти, называется кучей (не нужно путать с одноимённой структурой данных).
∙ Выделение и освобождение памяти управляется вручную.


∙ Стандартная библиотека cstdlib предоставляет четыре функции для управления памятью:
void * malloc ( size_t size );
void free ( void * ptr );
void * calloc ( size_t nmemb , size_t size );
void * realloc ( void * ptr , size_t size );
∙ size_t — специальный целочисленный беззнаковый тип, может вместить в себя размер любого типа в байтах.
∙ Тип size_t используется для указания размеров типов данных, для индексации массивов и пр.
∙ void * — это указатель на нетипизированную память (раньше для этого использовалось char *).

∙ Язык C++ предоставляет два набора операторов для выделения памяти:
1. new и delete — для одиночных значений,
2. new [] и delete [] — для массивов.
∙ Версия оператора delete должна соответствовать версии оператора new.
// выделение памяти под один int со значением 5
int * m = new int (5);
delete m ; // освобождение памяти
// создание массива значений типа int
m = new int [1000];
delete [] m ; // освобождение памяти


Типичные проблемы при работе с памятью
∙ Проблемы производительности: создание переменной на стеке намного “дешевле” выделения для неё динамической памяти.
∙ Проблема фрагментации: выделение большого количества небольших сегментов способствует фрагментации памяти.
∙ Утечки памяти:
// создание массива из 1000 int
int * m = new int [1000];
// создание массива из 2000 int
m = new int [2000]; // утечка памяти
// Не вызван delete [] m, утечка памяти

