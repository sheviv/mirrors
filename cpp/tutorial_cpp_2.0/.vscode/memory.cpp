// Освобождение памяти
int *ptr1 = new int (7); // используем прямую инициализацию
int *ptr2 = new int { 8 }; // используем uniform-инициализацию

// Предположим, что ptr ранее уже был выделен с помощью оператора new
delete ptr; // возвращаем память, на которую указывал ptr, обратно в операционную систему
ptr = 0; // делаем ptr нулевым указателем (используйте nullptr вместо 0 в C++11)


////////

// указатель value станет нулевым, если динамическое выделение целочисленной переменной не выполнится
int *value = new (std::nothrow) int; // запрос на выделение динамической памяти для целочисленного значения
if (!value) // обрабатываем случай, когда new возвращает null (т.е. память не выделяется)
{
    // Обработка этого случая
    std::cout << "Could not allocate memory";
}

///////

// Нулевые указатели и динамическое выделение памяти
// Если для ptr до сих пор не выделено памяти, то выделяем её
if (!ptr)
    ptr = new int;


////////

// утечка памяти может возникнуть и из-за того, что указатель выходит из области видимости
int value = 7;
int *ptr = new int; // выделяем память
delete ptr; // возвращаем память обратно в операционную систему
ptr = &value; // переприсваиваем указателю адрес value

